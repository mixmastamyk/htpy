{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#htpy-html-in-python","title":"htpy - HTML in Python","text":"<p>htpy is a library that makes writing HTML in Python fun and efficient, without the need for a template language.</p> <ul> <li> <p>Define HTML elements in Python...</p> <pre><code>from htpy import html, body, h1, img\n\nis_cool = True\n\nprint(html[\n  body(class_={\"cool\": is_cool})[\n    h1(\"#hi\")[\"Welcome to htpy!\"],\n    img(src=\"cat.jpg\"),\n  ]\n])\n</code></pre> </li> <li> <p>...and render it as HTML. <pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n  &lt;body class=\"cool\"&gt;\n    &lt;h1 id=\"hi\"&gt;Welcome to htpy!&lt;/h1&gt;\n    &lt;img src=\"cat.jpg\"&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p> </li> </ul>"},{"location":"#introduction","title":"Introduction","text":"<p>At Personalkollen, where htpy was originally developed we often found ourselves hitting walls when using classic templates. htpy was created to improve the productiveness and experience of generating HTML from a Python backend.</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li> <p>Leverage static types: - Use mypy or pyright to type check your code.</p> </li> <li> <p>Great debugging: Avoid cryptic stack traces from templates. Use your favorite Python debugger.</p> </li> <li> <p>Easy to extend: There is no special way to define template tags/filters. Just call regular functions.</p> </li> <li> <p>Create reusable components: Define components, snippets, complex layouts/pages as regular Python variables or functions.</p> </li> <li> <p>Familiar concepts from React: React helped make it popular writing HTML with a programming language. htpy uses a lot of similar constructs.</p> </li> </ul>"},{"location":"common-patterns/","title":"Common patterns","text":"<p>htpy itself is a library that does not impose any particular structure for your code. You have the full power of Python functions, classes and modules at your disposal.</p> <p>General programming practices on how to structure modules, functions and classes apply to HTML generation with htpy.</p> <p>This page describes common scenarios and patterns that may help you structure your own project in a good way.</p>"},{"location":"common-patterns/#filemodule-structure","title":"File/module structure","text":"<p>It is generally a good idea to keep your HTML pages/components separate from HTTP request handling and \"business logic\".</p> <p>In Django, this means that the view function should not directly generate the HTML.</p> <p>Using a file named <code>components.py</code> can be a good idea. If you have many components, you may create a <code>components</code> package instead.</p> <p>Your component functions can accept arbitrary argument with the required data:</p> views.py<pre><code>from django.http import HttpResponse\n\nfrom . import components\n\ndef greeting(request):\n    return HttpResponse(components.greeting(\n        name=request.GET.get(\"name\", \"anonymous\"),\n    ))\n</code></pre> components.py<pre><code>def greeting(*, name):\n    return html[body[f\"hi {name}!\"]]\n</code></pre>"},{"location":"common-patterns/#creating-a-base-layout","title":"Creating a base layout","text":"<p>A common feature of template languages is to \"extend\" a base/parent template and specify placeholders. This can be achieved with a <code>base_layout</code> function:</p> components.py<pre><code>import datetime\n\nfrom htpy import body, div, h1, head, html, p, title\n\n\ndef base_layout(*, page_title=None, extra_head=None, content=None, body_class=None):\n    return html[\n        head[title[page_title], extra_head],\n        body(class_=body_class)[\n            content,\n            div(\"#footer\")[f\"Copyright {datetime.date.today().year} by Foo Inc.\"],\n        ],\n    ]\n\n\ndef index():\n    return base_layout(\n        page_title=\"Welcome!\",\n        body_class=\"green\",\n        content=[h1[\"Welcome to my site!\"], p[\"Hello and welcome!\"]],\n    )\n\n\ndef about():\n    return base_layout(\n        page_title=\"About us\",\n        content=[\n            h1[\"About us\"],\n            p[\"We love creating web sites!\"],\n        ],\n    )\n</code></pre>"},{"location":"common-patterns/#ui-components","title":"UI components","text":"<p>Creating higher level wrappers for common UI components can be a good idea to reduce repitition.</p> <p>Wrapping Bootstrap Modal could be achieved with a function like this:</p> Creating wrapper for Bootstrap Modal<pre><code>from markupsafe import Markup\n\nfrom htpy import button, div, h5, span\n\n\ndef bootstrap_modal(*, title, body=None, footer=None):\n    return div(\".modal\", tabindex=\"-1\", role=\"dialog\")[\n        div(\".modal-dialog\", role=\"document\")[\n            div(\".modal-content\")[\n                div(\".modal-header\")[\n                    div(\".modal-title\")[\n                        h5(\".modal-title\")[title],\n                        button(\n                            \".close\",\n                            type=\"button\",\n                            data_dismiss=\"modal\",\n                            aria_label=\"Close\",\n                        )[span(aria_hidden=\"true\")[Markup(\"&amp;times;\")]],\n                    ]\n                ],\n                div(\".modal-body\")[body],\n                footer and div(\".modal-footer\")[footer],\n            ]\n        ]\n    ]\n</code></pre>"},{"location":"django/","title":"Usage with Django","text":"<p>htpy is not tied to any specific web framework. Nonetheless, htpy works great when combined with Django. This page contains information and useful techniques on how to combine htpy and Django.</p>"},{"location":"django/#returning-a-htpy-response","title":"Returning a htpy response","text":"<p>htpy elements can be passed directly to <code>HttpResponse</code>:</p> views.py<pre><code>from django.http import HttpResponse\nfrom htpy import div\n\ndef my_view(request):\n    return HttpResponse(html[body[div[\"Hi Django!\"]]])\n</code></pre>"},{"location":"django/#using-htpy-as-part-of-an-existing-django-template","title":"Using htpy as part of an existing Django template","text":"<p>htpy elements are marked as \"safe\" and can be injected directly into Django templates:</p> base.html<pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;My Django Site&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;{{ content }}&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> views.py<pre><code>from django.shortcuts import render\n\nfrom htpy import h1\n\n\ndef index(request):\n    return render(request, \"base.html\", {\"content\": h1[\"Welcome to my site!\"]})\n</code></pre>"},{"location":"django/#render-a-django-form-with-htpy","title":"Render a Django form with htpy","text":"<p>CSRF token, form widgets and errors can be directly used within htpy elements:</p> forms.py<pre><code>from django import forms\n\n\nclass MyForm(forms.Form):\n    name = forms.CharField()\n</code></pre> views.py<pre><code>from django.http import HttpResponse\n\nfrom . import components\nfrom .forms import MyForm\n\n\ndef my_form(request):\n    form = MyForm(request.POST or None)\n    if form.is_valid():\n        return HttpResponse(components.my_form_success())\n\n    return HttpResponse(components.my_form(request, form))\n</code></pre> components.py<pre><code>from django.template.backends.utils import csrf_input\n\nfrom htpy import body, button, form, h1, head, html, title\n\n\ndef base(page_title, content):\n    return html[head[title[page_title]], body[content]]\n\n\ndef my_form(request, my_form):\n    return base(\n        \"My form\",\n        form(method=\"post\")[\n            csrf_input(request),\n            my_form.errors,\n            my_form[\"name\"],\n            button[\"Submit!\"],\n        ],\n    )\n\n\ndef my_form_success():\n    return base(\n        \"Success!\",\n        h1[\"Success! The form was valid!\"],\n    )\n</code></pre>"},{"location":"django/#implement-custom-form-widgets-with-htpy","title":"Implement custom form widgets with htpy","text":"<p>You can implement a custom form widget directly with htpy like this:</p> widgets.py<pre><code>from django.forms import widgets\n\nfrom htpy import sl_input\n\n\nclass ShoelaceInput(widgets.Widget):\n    \"\"\"\n    A form widget using Shoelace's &lt;sl-input&gt; element.\n    More info: https://shoelace.style/components/input\n    \"\"\"\n\n    def render(self, name, value, attrs=None, renderer=None):\n        return str(sl_input(attrs, name=name, value=value))\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#how-does-htpy-performance-compare-to-django-or-jinja-templates","title":"How does htpy performance compare to Django or Jinja templates?","text":"<p>The performance of HTML rendering is rarely the bottleneck in most web application. It is usually fast enough regardless of what method of constructing the HTML is being used.</p> <p>Given that it has been fast enough, there has not been much effort in optimizing htpy. It should be possible to significantly increase the effectiveness and we are open to contributions with benchmarks and speed improvements.</p> <p>That said, htpy is currently on par with Django templates when it comes to speed. Jinja2 is currently significantly faster than both Django templates and htpy. There is a small benchmark script in the repo that generates a table with 50 000 rows.</p>"},{"location":"faq/#can-htpy-generate-xmlxhtml","title":"Can htpy generate XML/XHTML?","text":"<p>No. Generating XML/XHTML is out of scope for this project. Use a XML library if you are looking to generate XML.</p> <p>htpy generates HTML, therefore \"void elements\" such as <code>&lt;br&gt;</code> does not include a trailing <code>/</code>.</p>"},{"location":"faq/#does-not-generating-html-from-python-means-that-mixing-up-concerns-between-presentation-and-business-logic","title":"Does not generating HTML from Python means that mixing up concerns between presentation and business logic?","text":"<p>With a template language, create HTML markup in separate files is enforced by design. Avoiding logic in the presentation layer is also mostly done by making the language very restrictive.</p> <p>It takes a little bit of planning and effort, but it is possible to have a nicely separated presentation layer that is free from logic. See Common patterns for more details on how you can structure your project.</p>"},{"location":"faq/#what-kind-of-black-magic-makes-from-htpy-import-whatever_element-work","title":"What kind of black magic makes <code>from htpy import whatever_element</code> work?","text":"<p>htpy uses the module level <code>__getattr__</code>. It was introduced in Python 3.7. It allows creating <code>Element</code> instances for any elements that are imported.</p>"},{"location":"faq/#why-does-htpy-not-provide-html-like-tag-syntax-with-angel-brackets-like-pyxl-and-jsx","title":"Why does htpy not provide HTML like tag syntax with angel brackets like pyxl and JSX?","text":"<p>htpy must be compatible with standard Python code formatters, editors and static type checkers. Unfortunately, it is not possible to support those workflows with a custom syntax without a massive effort to change those tools to support that syntax.</p>"},{"location":"references/","title":"References","text":"<p>htpy was heavily inspired by many other libraries and articles. This page lists some of them.</p>"},{"location":"references/#similar-libraries-and-tools","title":"Similar libraries and tools","text":"<ul> <li>JSX/React - Made writing HTML in a programming language popular.</li> <li>pyxl, pyxl3, pyxl4 - Write HTML in Python with JSX-like syntax. Not actively maintained.</li> <li>htbuilder - Very similar to htpy but does not currently support automatic escaping.</li> <li>breve - An early implementation of HTML in Python. Using getattr <code>[]</code> syntax for children. Not actively maintained.</li> <li>hyperscript - JavaScript library that also uses CSS selector-like syntax for specifying id and classes.</li> <li>hyperpython - A Python interpretation of hyperscript. Not actively maintained.</li> <li>h by Adam Johnson - Similar to htpy, uses call syntax (<code>()</code>) for attributes and getitem (<code>[]</code>) for children.</li> </ul>"},{"location":"references/#articles-about-html-generation-without-templates","title":"Articles about HTML generation without templates","text":"<ul> <li>Jeff Atwood - You're Doing It Wrong - Stack Overflow co-founder Jeff Atwood</li> <li>Tavis Rudd - Throw out your templates - Tavis Rudd, creator of Python template language \"Cheetah\" argues for creating HTML without templates.</li> <li>David Ford - 80% of my coding is doing this (or why templates are dead) - Discusses various techniques for rendering HTML.</li> </ul>"},{"location":"usage/","title":"Usage","text":"<p>Elements are imported directly from the <code>htpy</code> module as their name. HTML attributes are specified by parenthesis (<code>()</code> / \"call\"). Children are specified using square brackets (<code>[]</code> / \"getitem\").</p> <pre><code>&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; print(div(id=\"hi\")[\"Hello!\"])\n&lt;div id=\"hi\"&gt;Hello!&lt;/div&gt;\n</code></pre>"},{"location":"usage/#elements","title":"Elements","text":"<p>Children can be strings, markup, other elements or lists/iterators.</p> <p>Elements can be arbitrarily nested: Nested elements<pre><code>&gt;&gt;&gt; from htpy import article, section, p\n&gt;&gt;&gt; print(section[article[p[\"Lorem ipsum\"]]])\n&lt;section&gt;&lt;article&gt;&lt;p&gt;Lorem ipsum&lt;/p&gt;&lt;/article&gt;&lt;/section&gt;\n</code></pre></p>"},{"location":"usage/#textstrings","title":"Text/strings","text":"<p>It is possible to pass a string directly: Using a string as children<pre><code>&gt;&gt;&gt; from htpy import h1\n&gt;&gt;&gt; print(h1[\"Welcome to my site!\"])\n&lt;h1&gt;Welcome to my site!&lt;/h1&gt;\n</code></pre></p> <p>Strings are automatically escaped to avoid XSS vulnerabilities. It is convenient and safe to directly insert variable data via f-strings:</p> <pre><code>&gt;&gt;&gt; from htpy import h1\n&gt;&gt;&gt; user_supplied_name = \"bobby &lt;/h1&gt;\"\n&gt;&gt;&gt; print(h1[f\"hello {user_supplied_name}\"])\n&lt;h1&gt;hello bobby &amp;lt;/h1&amp;gt;&lt;/h1&gt;\n</code></pre>"},{"location":"usage/#conditional-rendering","title":"Conditional rendering","text":"<p><code>None</code> and <code>False</code> will not render anything. This can be useful to conditionally render some content.</p> Conditional rendering<pre><code>&gt;&gt;&gt; from htpy import div, b\n&gt;&gt;&gt; error = None\n\n&gt;&gt;&gt; # No &lt;b&gt; tag will be rendered since error is None\n&gt;&gt;&gt; print(div[error and b[error]])\n&lt;div&gt;&lt;/div&gt;\n\n&gt;&gt;&gt; error = 'Enter a valid email address.'\n&gt;&gt;&gt; print(div[error and b[error]])\n&lt;div&gt;&lt;b&gt;Enter a valid email address.&lt;/b&gt;&lt;/div&gt;\n\n# Inline if/else can also be used:\n&gt;&gt;&gt; print(div[b[error] if error else None])\n&lt;div&gt;&lt;b&gt;Enter a valid email address.&lt;/b&gt;&lt;/div&gt;\n</code></pre>"},{"location":"usage/#loops-iterating-over-children","title":"Loops / iterating over children","text":"<p>You can pass a list, tuple or generator to generate multiple children:</p> Iterate over a generator<pre><code>&gt;&gt;&gt; from htpy import ul, li\n&gt;&gt;&gt; print(ul[(li[letter] for letter in \"abc\")])\n&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;li&gt;b&lt;/li&gt;&lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;\n</code></pre> <p>A <code>list</code> can be used similar to a JSX fragment:</p> Render a list of child elements<pre><code>&gt;&gt;&gt; from htpy import div, img\n&gt;&gt;&gt; my_images = [img(src=\"a.jpg\"), img(src=\"b.jpg\")]\n&gt;&gt;&gt; print(div[my_images])\n&lt;div&gt;&lt;img src=\"a.jpg\"&gt;&lt;img src=\"b.jpg\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"usage/#custom-elements-web-components","title":"Custom elements / web components","text":"<p>Custom elements / web components are HTML elements that contains at least one dash (<code>-</code>). Since <code>-</code> cannot be used in Python identifiers, use underscore (<code>_</code>) instead:</p> Using custom elements<pre><code>&gt;&gt;&gt; from htpy import my_custom_element\n&gt;&gt;&gt; print(my_custom_element['hi!'])\n&lt;my-custom-element&gt;hi!&lt;/my-custom-element&gt;\n</code></pre>"},{"location":"usage/#injecting-markup","title":"Injecting markup","text":"<p>If you have HTML markup that you want to insert without further escaping, wrap it in <code>Markup</code> from the markupsafe library. markupsafe is a dependency of htpy and is automatically installed:</p> Injecting markup<pre><code>&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; from markupsafe import Markup\n&gt;&gt;&gt; print(div[Markup(\"&lt;foo&gt;&lt;/foo&gt;\")])\n&lt;div&gt;&lt;foo&gt;&lt;/foo&gt;&lt;/div&gt;\n</code></pre> <p>If you are generate Markdown and want to insert it into an element, use <code>Markup</code>: Injecting generated markdown<pre><code>&gt;&gt;&gt; from markdown import markdown\n&gt;&gt;&gt; from markupsafe import Markup\n&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; print(div[Markup(markdown('# Hi'))])\n&lt;div&gt;&lt;h1&gt;Hi&lt;/h1&gt;&lt;/div&gt;\n</code></pre></p>"},{"location":"usage/#html-doctype","title":"HTML Doctype","text":"<p>The HTML doctype is automatically prepended to the <code>&lt;html&gt;</code> tag:</p> <pre><code>&gt;&gt;&gt; from htpy import html\n&gt;&gt;&gt; print(html)\n&lt;!doctype html&gt;&lt;html&gt;&lt;/html&gt;\n</code></pre>"},{"location":"usage/#attributes","title":"Attributes","text":"<p>HTML attributes are defined by calling the element. They can be specified in a couple of different ways.</p>"},{"location":"usage/#elements-without-attributes","title":"Elements without attributes","text":"<p>Some elements do not have attributes, they can be specified by just the element itself:</p> <pre><code>&gt;&gt;&gt; from htpy import hr\n&gt;&gt;&gt; print(hr)\n&lt;hr&gt;\n</code></pre>"},{"location":"usage/#keyword-arguments","title":"Keyword arguments","text":"<p>Attributes can be specified via keyword arguments:</p> <pre><code>&gt;&gt;&gt; from htpy import img\n&gt;&gt;&gt; print(img(src=\"picture.jpg\"))\n&lt;img src=\"picture.jpg\"&gt;\n</code></pre> <p>In Python, <code>class</code> and <code>for</code> cannot be used as keyword arguments. Instead, they can be specified as <code>class_</code> or <code>for_</code> when using keyword arguments:</p> <pre><code>&gt;&gt;&gt; from htpy import img\n&gt;&gt;&gt; print(label(for_=\"myfield\"))\n&lt;label for=\"myfield\"&gt;&lt;/label&gt;\n</code></pre> <p>Attributes that contains dashes <code>-</code> can be specified using underscores: <pre><code>&gt;&gt;&gt; from htpy import form\n&gt;&gt;&gt; print(form(hx_post=\"/foo\"))\n&lt;form hx-post=\"/foo\"&gt;&lt;/form&gt;\n</code></pre></p> <p>If you need attributes</p>"},{"location":"usage/#idclass-shorthand","title":"id/class shorthand","text":"<p>Defining <code>id</code> and <code>class</code> attributes is common when writing HTML. A string shorthand that looks like a CSS selector can be used to quickly define id and classes:</p> Define id<pre><code>&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; print(div(\"#myid\"))\n&lt;div id=\"myid\"&gt;&lt;/div&gt;\n</code></pre> Define multiple classes<pre><code>&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; print(div(\".foo.bar\"))\n&lt;div id=\"foo bar\"&gt;&lt;/div&gt;\n</code></pre> Combining both id and classes<pre><code>&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; print(div(\"#myid.foo.bar\"))\n&lt;div id=\"myid\" class=\"foo bar\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"usage/#attributes-as-dict","title":"Attributes as dict","text":"<p>Attributes can also be specified as a <code>dict</code>. This is useful when using attributes that are reserved Python keywords (like <code>for</code> or <code>class</code>), when the attribute name contains a dash (<code>-</code>) or when you want to define attributes dynamically.</p> Using an attribute with a dash<pre><code>&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; print(div({\"data-foo\": \"bar\"}))\n&lt;div data-foo=\"bar\"&gt;&lt;/div&gt;\n</code></pre> Using an attribute with a reserved keyword<pre><code>&gt;&gt;&gt; from htpy import label\n&gt;&gt;&gt; print(label({\"for\": \"myfield\"}))\n&lt;label for=\"myfield\"&gt;&lt;/label&gt;\n</code></pre>"},{"location":"usage/#boolean-attributes","title":"Boolean attributes","text":"<p>In HTML, boolean attributes such as <code>disabled</code> are considered \"true\" when they exist. Specifying an attribute as <code>True</code> will make it appear (without a value). <code>False</code> will make it hidden. This is useful and brings the semantics of <code>bool</code> to HTML.</p> True bool attribute<pre><code>&gt;&gt;&gt; from htpy import button\n&gt;&gt;&gt; print(button(disabled=True))\n&lt;button disabled&gt;&lt;/button&gt;\n</code></pre> False bool attribute<pre><code>&gt;&gt;&gt; from htpy import button\n&gt;&gt;&gt; print(button(disabled=False))\n&lt;button&gt;&lt;/button&gt;\n</code></pre>"},{"location":"usage/#conditionally-mixing-css-classes","title":"Conditionally mixing CSS classes","text":"<p>To make it easier to mix CSS classes, the <code>class</code> attribute accepts a list of class names or a dict. Falsey values will be ignored.</p> <pre><code>&gt;&gt;&gt; from htpy import button\n&gt;&gt;&gt; is_primary = True\n&gt;&gt;&gt; print(button(class_=[\"btn\", {\"btn-primary\": is_primary}]))\n&lt;button class=\"btn btn-primary\"&gt;&lt;/button&gt;\n&gt;&gt;&gt; is_primary = False\n&gt;&gt;&gt; print(button(class_=[\"btn\", {\"btn-primary\": is_primary}]))\n&lt;button class=\"btn\"&gt;&lt;/button&gt;\n&gt;&gt;&gt;\n</code></pre>"},{"location":"usage/#combining-modes","title":"Combining modes","text":"<p>Attributes via id/class shorthand, keyword arguments and dictionary can be combined:</p> Specifying attribute via multiple arguments<pre><code>&gt;&gt;&gt; from htyp import label\n&gt;&gt;&gt; print(label(\"#myid.foo.bar\", {'for': \"somefield\"}, name=\"myname\",))\n&lt;label id=\"myid\" class=\"foo bar\" for=\"somefield\" name=\"myname\"&gt;&lt;/label&gt;\n</code></pre>"}]}