{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#htpy-html-in-python","title":"htpy - HTML in Python","text":"<p>htpy is a library that makes writing HTML in Python fun and efficient, without the need for a template language:</p> <pre><code>&gt;&gt;&gt; from htpy import html, head, title, body, h1\n&gt;&gt;&gt; print(html[head[title[\"Hello htpy\"]], body[\"hi!\"]])\n&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello htpy&lt;/title&gt;&lt;/head&gt;&lt;body&gt;hi!&lt;/body&gt;&lt;/html&gt;\n</code></pre>"},{"location":"#introduction","title":"Introduction","text":"<p>At Personalkollen, where htpy was originally developed we often found ourselves hitting walls when using classic templates. htpy was created to improve the productiveness and experience of generating HTML from a Python backend.</p>"},{"location":"#static-types","title":"Static types","text":"<p>We have been increasing static type coverage and seen great effects of static typing. But when it comes to HTML produced by templates, after the template context is created, static type checkers hit a wall. This looses a lot of the value of using a type checker since a lot of the code that use domain specific objects cannot be checked.</p>"},{"location":"#debugging","title":"Debugging","text":"<p>Debugging a template system can be hard. The stack traces are often cryptic and hides the real culprit of a problem. Inspecting/debugging the template context is not possible without special tooling or debuggers. Debugging code written with htpy works with any Python debugger and gives usable stack traces.</p>"},{"location":"#tooling","title":"Tooling","text":"<p>We are big fans of black to format our code. There are formatters that formats templates but we have found them lacking compared to tools like black.</p> <p>Many editors provide \"goto definition\". These often does not work reliably with templates.</p>"},{"location":"#extending","title":"Extending","text":"<p>Extending a template system with custom tags and filters requires learning about the template system parser and tokenizer, rather than just writing plain Python functions. Adding even a trivial filter requires putting the function in a specific location and registering the filter with the template library. Filters and tags with htpy are just plain Python functions.</p>"},{"location":"#creating-componentspartials","title":"Creating components/partials","text":"<p>Creating components/partials is typically done with includes or inclusion tags in a template language. With htpy, components/partials can be plain Python variables or functions. Making it easy to create partials and components makes it easier to maintain a library of components/partials.</p>"},{"location":"#familiar-concepts","title":"Familiar concepts","text":"<p>React/JSX has popularized the idea of using a programming language rather than a separate template language. The concept of building a tree of components and composing them with regular modules/classes/functions should be familiar to anyone with React/JSX experience.</p>"},{"location":"django/","title":"Usage with Django","text":"<p>htpy is not tied to any specific web framework. Nonetheless, htpy works great when combined with Django. This page contains information and useful techniques on how to combine htpy and Django.</p>"},{"location":"django/#returning-a-htpy-response","title":"Returning a htpy response","text":"<p>htpy elements can be passed directly to <code>HttpResponse</code>:</p> views.py<pre><code>from django.http import HttpResponse\nfrom htpy import div\n\ndef my_view(request):\n    return HttpResponse(html[body[div[\"Hi Django!\"]]])\n</code></pre>"},{"location":"django/#using-htpy-as-part-of-an-existing-django-template","title":"Using htpy as part of an existing Django template","text":"<p>htpy elements are marked as \"safe\" and can be injected directly into Django templates:</p> base.html<pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;My Django Site&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;{{ content }}&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> components.py<pre><code>from htpy import div\n\n\ndef index_content():\n    return div[\"Welcome to my site!\"]\n</code></pre> views.py<pre><code>from django.shortcuts import render\n\nfrom .components import index_content\n\n\ndef index(request):\n    return render(request, \"base.html\", {\"content\": index_content()})\n</code></pre>"},{"location":"django/#render-a-django-form-with-htpy","title":"Render a Django form with htpy","text":"<p>CSRF token, form widgets and errors can be directly used within htpy elements:</p> forms.py<pre><code>from django import forms\n\n\nclass MyForm(forms.Form):\n    name = forms.CharField()\n</code></pre> views.py<pre><code>from django.http import HttpResponse\n\nfrom . import components\nfrom .forms import MyForm\n\n\ndef my_form(request):\n    form = MyForm(request.POST or None)\n    if form.is_valid():\n        return HttpResponse(components.my_form_success())\n\n    return HttpResponse(components.my_form(request, form))\n</code></pre> components.py<pre><code>from django.template.backends.utils import csrf_input\n\nfrom htpy import body, button, form, h1, head, html, title\n\n\ndef base(page_title, content):\n    return html[head[title[page_title]], body[content]]\n\n\ndef my_form(request, my_form):\n    return base(\n        \"My form\",\n        form(method=\"post\")[\n            csrf_input(request),\n            my_form.errors,\n            my_form[\"name\"],\n            button[\"Submit!\"],\n        ],\n    )\n\n\ndef my_form_success():\n    return base(\n        \"Success!\",\n        h1[\"Success! The form was valid!\"],\n    )\n</code></pre>"},{"location":"django/#implement-custom-form-widgets-with-htpy","title":"Implement custom form widgets with htpy","text":"<p>You can implement a custom form widget directly with htpy like this:</p> widgets.py<pre><code>from django.forms import widgets\n\nfrom htpy import sl_input\n\n\nclass ShoelaceInput(widgets.Widget):\n    \"\"\"\n    A form widget using Shoelace's &lt;sl-input&gt; element.\n    More info: https://shoelace.style/components/input\n    \"\"\"\n\n    def render(self, name, value, attrs=None, renderer=None):\n        return str(sl_input(attrs, name=name, value=value))\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>Elements are imported directly from the <code>htpy</code> module as their name. HTML attributes are specified by parenthesis (<code>()</code> / \"call\"). Children are specified using square brackets (<code>[]</code> / \"getitem\").</p> <pre><code>&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; print(div(id=\"hi\")[\"Hello!\"])\n&lt;div id=\"hi\"&gt;Hello!&lt;/div&gt;\n</code></pre>"},{"location":"usage/#elements","title":"Elements","text":"<p>Children can be strings, markup, other elements or lists/iterators.</p> <p>Elements can be arbitrarily nested: Nested elements<pre><code>&gt;&gt;&gt; from htpy import article, section, p\n&gt;&gt;&gt; print(section[article[p[\"Lorem ipsum\"]]])\n&lt;section&gt;&lt;article&gt;&lt;p&gt;Lorem ipsum&lt;/p&gt;&lt;/article&gt;&lt;/section&gt;\n</code></pre></p>"},{"location":"usage/#textstrings","title":"Text/strings","text":"<p>It is possible to pass a string directly: Using a string as children<pre><code>&gt;&gt;&gt; from htpy import h1\n&gt;&gt;&gt; print(h1[\"Welcome to my site!\"])\n&lt;h1&gt;Welcome to my site!&lt;/h1&gt;\n</code></pre></p> <p>Strings are automatically escaped to avoid XSS vulnerabilities. It is convenient and safe to directly insert variable data via f-strings:</p> <pre><code>&gt;&gt;&gt; from htpy import h1\n&gt;&gt;&gt; user_supplied_name = \"bobby &lt;/h1&gt;\"\n&gt;&gt;&gt; print(h1[f\"hello {user_supplied_name}\"])\n&lt;h1&gt;hello bobby &amp;lt;/h1&amp;gt;&lt;/h1&gt;\n</code></pre>"},{"location":"usage/#conditional-rendering","title":"Conditional rendering","text":"<p><code>None</code> and <code>False</code> will not render anything. This can be useful to conditionally render some content.</p> Conditional rendering<pre><code>&gt;&gt;&gt; from htpy import div, b\n&gt;&gt;&gt; error = None\n\n&gt;&gt;&gt; # No &lt;b&gt; tag will be rendered since error is None\n&gt;&gt;&gt; print(div[error and b[error]])\n&lt;div&gt;&lt;/div&gt;\n\n&gt;&gt;&gt; error = 'Enter a valid email address.'\n&gt;&gt;&gt; print(div[error and b[error]])\n&lt;div&gt;&lt;b&gt;Enter a valid email address.&lt;/b&gt;&lt;/div&gt;\n\n# Inline if/else can also be used:\n&gt;&gt;&gt; print(div[b[error] if error else None])\n&lt;div&gt;&lt;b&gt;Enter a valid email address.&lt;/b&gt;&lt;/div&gt;\n</code></pre>"},{"location":"usage/#loops-iterating-over-children","title":"Loops / iterating over children","text":"<p>You can pass a list, tuple or generator to generate multiple children:</p> Iterate over a generator<pre><code>&gt;&gt;&gt; from htpy import ul, li\n&gt;&gt;&gt; print(ul[(li[letter] for letter in \"abc\")])\n&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;li&gt;b&lt;/li&gt;&lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;\n</code></pre> <p>A <code>list</code> can be used similar to a JSX fragment:</p> Render a list of child elements<pre><code>&gt;&gt;&gt; from htpy import div, img\n&gt;&gt;&gt; my_images = [img(src=\"a.jpg\"), img(src=\"b.jpg\")]\n&gt;&gt;&gt; print(div[my_images])\n&lt;div&gt;&lt;img src=\"a.jpg\"&gt;&lt;img src=\"b.jpg\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"usage/#custom-elements-web-components","title":"Custom elements / web components","text":"<p>Custom elements / web components are HTML elements that contains at least one dash (<code>-</code>). Since <code>-</code> cannot be used in Python identifiers, use underscore (<code>_</code>) instead:</p> Using custom elements<pre><code>&gt;&gt;&gt; from htpy import my_custom_element\n&gt;&gt;&gt; print(my_custom_element['hi!'])\n&lt;my-custom-element&gt;hi!&lt;/my-custom-element&gt;\n</code></pre>"},{"location":"usage/#injecting-markup","title":"Injecting markup","text":"<p>If you have HTML markup that you want to insert without further escaping, wrap it in <code>Markup</code> from the markupsafe library. markupsafe is a dependency of htpy and is automatically installed:</p> Injecting markup<pre><code>&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; from markupsafe import Markup\n&gt;&gt;&gt; print(div[Markup(\"&lt;foo&gt;&lt;/foo&gt;\")])\n&lt;div&gt;&lt;foo&gt;&lt;/foo&gt;&lt;/div&gt;\n</code></pre>"},{"location":"usage/#attributes","title":"Attributes","text":"<p>HTML attributes are defined by calling the element. They can be specified in a couple of different ways.</p>"},{"location":"usage/#elements-without-attributes","title":"Elements without attributes","text":"<p>Some elements do not have attributes, they can be specified by just the element itself:</p> <pre><code>&gt;&gt;&gt; from htpy import hr\n&gt;&gt;&gt; print(hr)\n&lt;hr&gt;\n</code></pre>"},{"location":"usage/#keyword-arguments","title":"Keyword arguments","text":"<p>Attributes can be specified via keyword arguments:</p> <pre><code>&gt;&gt;&gt; from htpy import img\n&gt;&gt;&gt; print(img(src=\"picture.jpg\"))\n&lt;img src=\"picture.jpg\"&gt;\n</code></pre> <p>In Python, <code>class</code> and <code>for</code> cannot be used as keyword arguments. Instead, they can be specified as <code>class_</code> or <code>for_</code> when using keyword arguments:</p> <pre><code>&gt;&gt;&gt; from htpy import img\n&gt;&gt;&gt; print(label(for_=\"myfield\"))\n&lt;label for=\"myfield\"&gt;&lt;/label&gt;\n</code></pre> <p>Attributes that contains dashes <code>-</code> can be specified using underscores: <pre><code>&gt;&gt;&gt; from htpy import form\n&gt;&gt;&gt; print(form(hx_post=\"/foo\"))\n&lt;form hx-post=\"/foo\"&gt;&lt;/form&gt;\n</code></pre></p> <p>If you need attributes</p>"},{"location":"usage/#idclass-shorthand","title":"id/class shorthand","text":"<p>Defining <code>id</code> and <code>class</code> attributes is common when writing HTML. A string shorthand that looks like a CSS selector can be used to quickly define id and classes:</p> Define id<pre><code>&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; print(div(\"#myid\"))\n&lt;div id=\"myid\"&gt;&lt;/div&gt;\n</code></pre> Define multiple classes<pre><code>&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; print(div(\".foo.bar\"))\n&lt;div id=\"foo bar\"&gt;&lt;/div&gt;\n</code></pre> Combining both id and classes<pre><code>&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; print(div(\"#myid.foo.bar\"))\n&lt;div id=\"myid\" class=\"foo bar\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"usage/#attributes-as-dict","title":"Attributes as dict","text":"<p>Attributes can also be specified as a <code>dict</code>. This is useful when using attributes that are reserved Python keywords (like <code>for</code> or <code>class</code>), when the attribute name contains a dash (<code>-</code>) or when you want to define attributes dynamically.</p> Using an attribute with a dash<pre><code>&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; print(div({\"data-foo\": \"bar\"}))\n&lt;div data-foo=\"bar\"&gt;&lt;/div&gt;\n</code></pre> Using an attribute with a reserved keyword<pre><code>&gt;&gt;&gt; from htpy import label\n&gt;&gt;&gt; print(label({\"for\": \"myfield\"}))\n&lt;label for=\"myfield\"&gt;&lt;/label&gt;\n</code></pre>"},{"location":"usage/#boolean-attributes","title":"Boolean attributes","text":"<p>In HTML, boolean attributes such as <code>disabled</code> are considered \"true\" when they exist. Specifying an attribute as <code>True</code> will make it appear (without a value). <code>False</code> will make it hidden. This is useful and brings the semantics of <code>bool</code> to HTML.</p> True bool attribute<pre><code>&gt;&gt;&gt; from htpy import button\n&gt;&gt;&gt; print(button(disabled=True))\n&lt;button disabled&gt;&lt;/button&gt;\n</code></pre> False bool attribute<pre><code>&gt;&gt;&gt; from htpy import button\n&gt;&gt;&gt; print(button(disabled=False))\n&lt;button&gt;&lt;/button&gt;\n</code></pre>"},{"location":"usage/#conditionally-mixing-css-classes","title":"Conditionally mixing CSS classes","text":"<p>To make it easier to mix CSS classes, the <code>class</code> attribute accepts a list of class names or a dict. Falsey values will be ignored.</p> <pre><code>&gt;&gt;&gt; from htpy import button\n&gt;&gt;&gt; is_primary = True\n&gt;&gt;&gt; print(button(class_=[\"btn\", {\"btn-primary\": is_primary}]))\n&lt;button class=\"btn btn-primary\"&gt;&lt;/button&gt;\n&gt;&gt;&gt; is_primary = False\n&gt;&gt;&gt; print(button(class_=[\"btn\", {\"btn-primary\": is_primary}]))\n&lt;button class=\"btn\"&gt;&lt;/button&gt;\n&gt;&gt;&gt;\n</code></pre>"},{"location":"usage/#combining-modes","title":"Combining modes","text":"<p>Attributes via id/class shorthand, keyword arguments and dictionary can be combined:</p> Specifying attribute via multiple arguments<pre><code>&gt;&gt;&gt; from htyp import label\n&gt;&gt;&gt; print(label(\"#myid.foo.bar\", {'for': \"somefield\"}, name=\"myname\",))\n&lt;label id=\"myid\" class=\"foo bar\" for=\"somefield\" name=\"myname\"&gt;&lt;/label&gt;\n</code></pre>"}]}